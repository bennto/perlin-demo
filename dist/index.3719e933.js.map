{"mappings":"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","sources":["<anon>","src/perlin.js"],"sourcesContent":["/*\r\n * A speed-improved perlin and simplex noise algorithms for 2D.\r\n *\r\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\r\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\r\n * Better rank ordering method by Stefan Gustavson in 2012.\r\n * Converted to Javascript by Joseph Gentle.\r\n *\r\n * Version 2012-03-09\r\n *\r\n * This code was placed in the public domain by its original author,\r\n * Stefan Gustavson. You may use it as you see fit, but\r\n * attribution is appreciated.\r\n *\r\n */ (function(global) {\n    var module = global.noise = {};\n    function Grad(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    Grad.prototype.dot2 = function(x, y) {\n        return this.x * x + this.y * y;\n    };\n    Grad.prototype.dot3 = function(x, y, z) {\n        return this.x * x + this.y * y + this.z * z;\n    };\n    var grad3 = [\n        new Grad(1, 1, 0),\n        new Grad(-1, 1, 0),\n        new Grad(1, -1, 0),\n        new Grad(-1, -1, 0),\n        new Grad(1, 0, 1),\n        new Grad(-1, 0, 1),\n        new Grad(1, 0, -1),\n        new Grad(-1, 0, -1),\n        new Grad(0, 1, 1),\n        new Grad(0, -1, 1),\n        new Grad(0, 1, -1),\n        new Grad(0, -1, -1)\n    ];\n    var p = [\n        151,\n        160,\n        137,\n        91,\n        90,\n        15,\n        131,\n        13,\n        201,\n        95,\n        96,\n        53,\n        194,\n        233,\n        7,\n        225,\n        140,\n        36,\n        103,\n        30,\n        69,\n        142,\n        8,\n        99,\n        37,\n        240,\n        21,\n        10,\n        23,\n        190,\n        6,\n        148,\n        247,\n        120,\n        234,\n        75,\n        0,\n        26,\n        197,\n        62,\n        94,\n        252,\n        219,\n        203,\n        117,\n        35,\n        11,\n        32,\n        57,\n        177,\n        33,\n        88,\n        237,\n        149,\n        56,\n        87,\n        174,\n        20,\n        125,\n        136,\n        171,\n        168,\n        68,\n        175,\n        74,\n        165,\n        71,\n        134,\n        139,\n        48,\n        27,\n        166,\n        77,\n        146,\n        158,\n        231,\n        83,\n        111,\n        229,\n        122,\n        60,\n        211,\n        133,\n        230,\n        220,\n        105,\n        92,\n        41,\n        55,\n        46,\n        245,\n        40,\n        244,\n        102,\n        143,\n        54,\n        65,\n        25,\n        63,\n        161,\n        1,\n        216,\n        80,\n        73,\n        209,\n        76,\n        132,\n        187,\n        208,\n        89,\n        18,\n        169,\n        200,\n        196,\n        135,\n        130,\n        116,\n        188,\n        159,\n        86,\n        164,\n        100,\n        109,\n        198,\n        173,\n        186,\n        3,\n        64,\n        52,\n        217,\n        226,\n        250,\n        124,\n        123,\n        5,\n        202,\n        38,\n        147,\n        118,\n        126,\n        255,\n        82,\n        85,\n        212,\n        207,\n        206,\n        59,\n        227,\n        47,\n        16,\n        58,\n        17,\n        182,\n        189,\n        28,\n        42,\n        223,\n        183,\n        170,\n        213,\n        119,\n        248,\n        152,\n        2,\n        44,\n        154,\n        163,\n        70,\n        221,\n        153,\n        101,\n        155,\n        167,\n        43,\n        172,\n        9,\n        129,\n        22,\n        39,\n        253,\n        19,\n        98,\n        108,\n        110,\n        79,\n        113,\n        224,\n        232,\n        178,\n        185,\n        112,\n        104,\n        218,\n        246,\n        97,\n        228,\n        251,\n        34,\n        242,\n        193,\n        238,\n        210,\n        144,\n        12,\n        191,\n        179,\n        162,\n        241,\n        81,\n        51,\n        145,\n        235,\n        249,\n        14,\n        239,\n        107,\n        49,\n        192,\n        214,\n        31,\n        181,\n        199,\n        106,\n        157,\n        184,\n        84,\n        204,\n        176,\n        115,\n        121,\n        50,\n        45,\n        127,\n        4,\n        150,\n        254,\n        138,\n        236,\n        205,\n        93,\n        222,\n        114,\n        67,\n        29,\n        24,\n        72,\n        243,\n        141,\n        128,\n        195,\n        78,\n        66,\n        215,\n        61,\n        156,\n        180\n    ];\n    // To remove the need for index wrapping, double the permutation table length\n    var perm = new Array(512);\n    var gradP = new Array(512);\n    // This isn't a very good seeding function, but it works ok. It supports 2^16\n    // different seed values. Write something better if you need more seeds.\n    module.seed = function(seed) {\n        if (seed > 0 && seed < 1) // Scale the seed out\n        seed *= 65536;\n        seed = Math.floor(seed);\n        if (seed < 256) seed |= seed << 8;\n        for(var i = 0; i < 256; i++){\n            var v;\n            if (i & 1) v = p[i] ^ seed & 255;\n            else v = p[i] ^ seed >> 8 & 255;\n            perm[i] = perm[i + 256] = v;\n            gradP[i] = gradP[i + 256] = grad3[v % 12];\n        }\n    };\n    module.seed(0);\n    /*\r\n    for(var i=0; i<256; i++) {\r\n      perm[i] = perm[i + 256] = p[i];\r\n      gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\r\n    }*/ // Skewing and unskewing factors for 2, 3, and 4 dimensions\n    var F2 = 0.5 * (Math.sqrt(3) - 1);\n    var G2 = (3 - Math.sqrt(3)) / 6;\n    var F3 = 1 / 3;\n    var G3 = 1 / 6;\n    // 2D simplex noise\n    module.simplex2 = function(xin, yin) {\n        var n0, n1, n2; // Noise contributions from the three corners\n        // Skew the input space to determine which simplex cell we're in\n        var s = (xin + yin) * F2; // Hairy factor for 2D\n        var i = Math.floor(xin + s);\n        var j = Math.floor(yin + s);\n        var t = (i + j) * G2;\n        var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n        var y0 = yin - j + t;\n        // For the 2D case, the simplex shape is an equilateral triangle.\n        // Determine which simplex we are in.\n        var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n        if (x0 > y0) {\n            i1 = 1;\n            j1 = 0;\n        } else {\n            i1 = 0;\n            j1 = 1;\n        }\n        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n        // c = (3-sqrt(3))/6\n        var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n        var y1 = y0 - j1 + G2;\n        var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n        var y2 = y0 - 1 + 2 * G2;\n        // Work out the hashed gradient indices of the three simplex corners\n        i &= 255;\n        j &= 255;\n        var gi0 = gradP[i + perm[j]];\n        var gi1 = gradP[i + i1 + perm[j + j1]];\n        var gi2 = gradP[i + 1 + perm[j + 1]];\n        // Calculate the contribution from the three corners\n        var t0 = 0.5 - x0 * x0 - y0 * y0;\n        if (t0 < 0) n0 = 0;\n        else {\n            t0 *= t0;\n            n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient\n        }\n        var t1 = 0.5 - x1 * x1 - y1 * y1;\n        if (t1 < 0) n1 = 0;\n        else {\n            t1 *= t1;\n            n1 = t1 * t1 * gi1.dot2(x1, y1);\n        }\n        var t2 = 0.5 - x2 * x2 - y2 * y2;\n        if (t2 < 0) n2 = 0;\n        else {\n            t2 *= t2;\n            n2 = t2 * t2 * gi2.dot2(x2, y2);\n        }\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to return values in the interval [-1,1].\n        return 70 * (n0 + n1 + n2);\n    };\n    // 3D simplex noise\n    module.simplex3 = function(xin, yin, zin) {\n        var n0, n1, n2, n3; // Noise contributions from the four corners\n        // Skew the input space to determine which simplex cell we're in\n        var s = (xin + yin + zin) * F3; // Hairy factor for 2D\n        var i = Math.floor(xin + s);\n        var j = Math.floor(yin + s);\n        var k = Math.floor(zin + s);\n        var t = (i + j + k) * G3;\n        var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\n        var y0 = yin - j + t;\n        var z0 = zin - k + t;\n        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n        // Determine which simplex we are in.\n        var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n        var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n        if (x0 >= y0) {\n            if (y0 >= z0) {\n                i1 = 1;\n                j1 = 0;\n                k1 = 0;\n                i2 = 1;\n                j2 = 1;\n                k2 = 0;\n            } else if (x0 >= z0) {\n                i1 = 1;\n                j1 = 0;\n                k1 = 0;\n                i2 = 1;\n                j2 = 0;\n                k2 = 1;\n            } else {\n                i1 = 0;\n                j1 = 0;\n                k1 = 1;\n                i2 = 1;\n                j2 = 0;\n                k2 = 1;\n            }\n        } else {\n            if (y0 < z0) {\n                i1 = 0;\n                j1 = 0;\n                k1 = 1;\n                i2 = 0;\n                j2 = 1;\n                k2 = 1;\n            } else if (x0 < z0) {\n                i1 = 0;\n                j1 = 1;\n                k1 = 0;\n                i2 = 0;\n                j2 = 1;\n                k2 = 1;\n            } else {\n                i1 = 0;\n                j1 = 1;\n                k1 = 0;\n                i2 = 1;\n                j2 = 1;\n                k2 = 0;\n            }\n        }\n        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n        // c = 1/6.\n        var x1 = x0 - i1 + G3; // Offsets for second corner\n        var y1 = y0 - j1 + G3;\n        var z1 = z0 - k1 + G3;\n        var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n        var y2 = y0 - j2 + 2 * G3;\n        var z2 = z0 - k2 + 2 * G3;\n        var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n        var y3 = y0 - 1 + 3 * G3;\n        var z3 = z0 - 1 + 3 * G3;\n        // Work out the hashed gradient indices of the four simplex corners\n        i &= 255;\n        j &= 255;\n        k &= 255;\n        var gi0 = gradP[i + perm[j + perm[k]]];\n        var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];\n        var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];\n        var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]];\n        // Calculate the contribution from the four corners\n        var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n        if (t0 < 0) n0 = 0;\n        else {\n            t0 *= t0;\n            n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient\n        }\n        var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n        if (t1 < 0) n1 = 0;\n        else {\n            t1 *= t1;\n            n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n        }\n        var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n        if (t2 < 0) n2 = 0;\n        else {\n            t2 *= t2;\n            n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n        }\n        var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n        if (t3 < 0) n3 = 0;\n        else {\n            t3 *= t3;\n            n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n        }\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to return values in the interval [-1,1].\n        return 32 * (n0 + n1 + n2 + n3);\n    };\n    // ##### Perlin noise stuff\n    function fade(t) {\n        return t * t * t * (t * (t * 6 - 15) + 10);\n    }\n    function lerp(a, b, t) {\n        return (1 - t) * a + t * b;\n    }\n    // 2D Perlin Noise\n    module.perlin2 = function(x, y) {\n        // Find unit grid cell containing point\n        var X = Math.floor(x), Y = Math.floor(y);\n        // Get relative xy coordinates of point within that cell\n        x = x - X;\n        y = y - Y;\n        // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n        X = X & 255;\n        Y = Y & 255;\n        // Calculate noise contributions from each of the four corners\n        var n00 = gradP[X + perm[Y]].dot2(x, y);\n        var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);\n        var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);\n        var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);\n        // Compute the fade curve value for x\n        var u = fade(x);\n        // Interpolate the four results\n        return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));\n    };\n    // 3D Perlin Noise\n    module.perlin3 = function(x, y, z) {\n        // Find unit grid cell containing point\n        var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\n        // Get relative xyz coordinates of point within that cell\n        x = x - X;\n        y = y - Y;\n        z = z - Z;\n        // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n        X = X & 255;\n        Y = Y & 255;\n        Z = Z & 255;\n        // Calculate noise contributions from each of the eight corners\n        var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);\n        var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);\n        var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);\n        var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);\n        var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);\n        var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);\n        var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);\n        var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1);\n        // Compute the fade curve value for x, y, z\n        var u = fade(x);\n        var v = fade(y);\n        var w = fade(z);\n        // Interpolate\n        return lerp(lerp(lerp(n000, n100, u), lerp(n001, n101, u), w), lerp(lerp(n010, n110, u), lerp(n011, n111, u), w), v);\n    };\n})(this);\n\n//# sourceMappingURL=index.3719e933.js.map\n","/*\r\n * A speed-improved perlin and simplex noise algorithms for 2D.\r\n *\r\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\r\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\r\n * Better rank ordering method by Stefan Gustavson in 2012.\r\n * Converted to Javascript by Joseph Gentle.\r\n *\r\n * Version 2012-03-09\r\n *\r\n * This code was placed in the public domain by its original author,\r\n * Stefan Gustavson. You may use it as you see fit, but\r\n * attribution is appreciated.\r\n *\r\n */\r\n\r\n(function(global){\r\n    var module = global.noise = {};\r\n  \r\n    function Grad(x, y, z) {\r\n      this.x = x; this.y = y; this.z = z;\r\n    }\r\n    \r\n    Grad.prototype.dot2 = function(x, y) {\r\n      return this.x*x + this.y*y;\r\n    };\r\n  \r\n    Grad.prototype.dot3 = function(x, y, z) {\r\n      return this.x*x + this.y*y + this.z*z;\r\n    };\r\n  \r\n    var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\r\n                 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\r\n                 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\r\n  \r\n    var p = [151,160,137,91,90,15,\r\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\r\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\r\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\r\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\r\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\r\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\r\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\r\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\r\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\r\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\r\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\r\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\r\n    // To remove the need for index wrapping, double the permutation table length\r\n    var perm = new Array(512);\r\n    var gradP = new Array(512);\r\n  \r\n    // This isn't a very good seeding function, but it works ok. It supports 2^16\r\n    // different seed values. Write something better if you need more seeds.\r\n    module.seed = function(seed) {\r\n      if(seed > 0 && seed < 1) {\r\n        // Scale the seed out\r\n        seed *= 65536;\r\n      }\r\n  \r\n      seed = Math.floor(seed);\r\n      if(seed < 256) {\r\n        seed |= seed << 8;\r\n      }\r\n  \r\n      for(var i = 0; i < 256; i++) {\r\n        var v;\r\n        if (i & 1) {\r\n          v = p[i] ^ (seed & 255);\r\n        } else {\r\n          v = p[i] ^ ((seed>>8) & 255);\r\n        }\r\n  \r\n        perm[i] = perm[i + 256] = v;\r\n        gradP[i] = gradP[i + 256] = grad3[v % 12];\r\n      }\r\n    };\r\n  \r\n    module.seed(0);\r\n  \r\n    /*\r\n    for(var i=0; i<256; i++) {\r\n      perm[i] = perm[i + 256] = p[i];\r\n      gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\r\n    }*/\r\n  \r\n    // Skewing and unskewing factors for 2, 3, and 4 dimensions\r\n    var F2 = 0.5*(Math.sqrt(3)-1);\r\n    var G2 = (3-Math.sqrt(3))/6;\r\n  \r\n    var F3 = 1/3;\r\n    var G3 = 1/6;\r\n  \r\n    // 2D simplex noise\r\n    module.simplex2 = function(xin, yin) {\r\n      var n0, n1, n2; // Noise contributions from the three corners\r\n      // Skew the input space to determine which simplex cell we're in\r\n      var s = (xin+yin)*F2; // Hairy factor for 2D\r\n      var i = Math.floor(xin+s);\r\n      var j = Math.floor(yin+s);\r\n      var t = (i+j)*G2;\r\n      var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\r\n      var y0 = yin-j+t;\r\n      // For the 2D case, the simplex shape is an equilateral triangle.\r\n      // Determine which simplex we are in.\r\n      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\r\n      if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\r\n        i1=1; j1=0;\r\n      } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\r\n        i1=0; j1=1;\r\n      }\r\n      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\r\n      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\r\n      // c = (3-sqrt(3))/6\r\n      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\r\n      var y1 = y0 - j1 + G2;\r\n      var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\r\n      var y2 = y0 - 1 + 2 * G2;\r\n      // Work out the hashed gradient indices of the three simplex corners\r\n      i &= 255;\r\n      j &= 255;\r\n      var gi0 = gradP[i+perm[j]];\r\n      var gi1 = gradP[i+i1+perm[j+j1]];\r\n      var gi2 = gradP[i+1+perm[j+1]];\r\n      // Calculate the contribution from the three corners\r\n      var t0 = 0.5 - x0*x0-y0*y0;\r\n      if(t0<0) {\r\n        n0 = 0;\r\n      } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\r\n      }\r\n      var t1 = 0.5 - x1*x1-y1*y1;\r\n      if(t1<0) {\r\n        n1 = 0;\r\n      } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * gi1.dot2(x1, y1);\r\n      }\r\n      var t2 = 0.5 - x2*x2-y2*y2;\r\n      if(t2<0) {\r\n        n2 = 0;\r\n      } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * gi2.dot2(x2, y2);\r\n      }\r\n      // Add contributions from each corner to get the final noise value.\r\n      // The result is scaled to return values in the interval [-1,1].\r\n      return 70 * (n0 + n1 + n2);\r\n    };\r\n  \r\n    // 3D simplex noise\r\n    module.simplex3 = function(xin, yin, zin) {\r\n      var n0, n1, n2, n3; // Noise contributions from the four corners\r\n  \r\n      // Skew the input space to determine which simplex cell we're in\r\n      var s = (xin+yin+zin)*F3; // Hairy factor for 2D\r\n      var i = Math.floor(xin+s);\r\n      var j = Math.floor(yin+s);\r\n      var k = Math.floor(zin+s);\r\n  \r\n      var t = (i+j+k)*G3;\r\n      var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\r\n      var y0 = yin-j+t;\r\n      var z0 = zin-k+t;\r\n  \r\n      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\r\n      // Determine which simplex we are in.\r\n      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\r\n      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\r\n      if(x0 >= y0) {\r\n        if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }\r\n        else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }\r\n        else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }\r\n      } else {\r\n        if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }\r\n        else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }\r\n        else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }\r\n      }\r\n      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\r\n      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\r\n      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\r\n      // c = 1/6.\r\n      var x1 = x0 - i1 + G3; // Offsets for second corner\r\n      var y1 = y0 - j1 + G3;\r\n      var z1 = z0 - k1 + G3;\r\n  \r\n      var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\r\n      var y2 = y0 - j2 + 2 * G3;\r\n      var z2 = z0 - k2 + 2 * G3;\r\n  \r\n      var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\r\n      var y3 = y0 - 1 + 3 * G3;\r\n      var z3 = z0 - 1 + 3 * G3;\r\n  \r\n      // Work out the hashed gradient indices of the four simplex corners\r\n      i &= 255;\r\n      j &= 255;\r\n      k &= 255;\r\n      var gi0 = gradP[i+   perm[j+   perm[k   ]]];\r\n      var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];\r\n      var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];\r\n      var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];\r\n  \r\n      // Calculate the contribution from the four corners\r\n      var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\r\n      if(t0<0) {\r\n        n0 = 0;\r\n      } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\r\n      }\r\n      var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\r\n      if(t1<0) {\r\n        n1 = 0;\r\n      } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\r\n      }\r\n      var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\r\n      if(t2<0) {\r\n        n2 = 0;\r\n      } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\r\n      }\r\n      var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\r\n      if(t3<0) {\r\n        n3 = 0;\r\n      } else {\r\n        t3 *= t3;\r\n        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\r\n      }\r\n      // Add contributions from each corner to get the final noise value.\r\n      // The result is scaled to return values in the interval [-1,1].\r\n      return 32 * (n0 + n1 + n2 + n3);\r\n  \r\n    };\r\n  \r\n    // ##### Perlin noise stuff\r\n  \r\n    function fade(t) {\r\n      return t*t*t*(t*(t*6-15)+10);\r\n    }\r\n  \r\n    function lerp(a, b, t) {\r\n      return (1-t)*a + t*b;\r\n    }\r\n  \r\n    // 2D Perlin Noise\r\n    module.perlin2 = function(x, y) {\r\n      // Find unit grid cell containing point\r\n      var X = Math.floor(x), Y = Math.floor(y);\r\n      // Get relative xy coordinates of point within that cell\r\n      x = x - X; y = y - Y;\r\n      // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n      X = X & 255; Y = Y & 255;\r\n  \r\n      // Calculate noise contributions from each of the four corners\r\n      var n00 = gradP[X+perm[Y]].dot2(x, y);\r\n      var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);\r\n      var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);\r\n      var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);\r\n  \r\n      // Compute the fade curve value for x\r\n      var u = fade(x);\r\n  \r\n      // Interpolate the four results\r\n      return lerp(\r\n          lerp(n00, n10, u),\r\n          lerp(n01, n11, u),\r\n         fade(y));\r\n    };\r\n  \r\n    // 3D Perlin Noise\r\n    module.perlin3 = function(x, y, z) {\r\n      // Find unit grid cell containing point\r\n      var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\r\n      // Get relative xyz coordinates of point within that cell\r\n      x = x - X; y = y - Y; z = z - Z;\r\n      // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n      X = X & 255; Y = Y & 255; Z = Z & 255;\r\n  \r\n      // Calculate noise contributions from each of the eight corners\r\n      var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);\r\n      var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);\r\n      var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);\r\n      var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);\r\n      var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);\r\n      var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);\r\n      var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);\r\n      var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);\r\n  \r\n      // Compute the fade curve value for x, y, z\r\n      var u = fade(x);\r\n      var v = fade(y);\r\n      var w = fade(z);\r\n  \r\n      // Interpolate\r\n      return lerp(\r\n          lerp(\r\n            lerp(n000, n100, u),\r\n            lerp(n001, n101, u), w),\r\n          lerp(\r\n            lerp(n010, n110, u),\r\n            lerp(n011, n111, u), w),\r\n         v);\r\n    };\r\n  \r\n  })(this);"],"names":["global","module","noise","Grad","x","y","z","prototype","dot2","dot3","grad3","p","perm","Array","gradP","seed","Math","floor","v","i","F2","sqrt","G2","F3","G3","fade","t","simplex2","xin","yin","n0","n1","n2","i1","j1","s","j","x0","y0","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","simplex3","zin","n3","k1","i2","j2","k2","k","z0","z1","z2","x3","y3","z3","gi3","t3","perlin2","a","b","X","Y","n00","n01","n10","n11","u","perlin3","Z","n000","n001","n010","n011","n100","n101","n110","n111","w"],"version":3,"file":"index.3719e933.js.map"}